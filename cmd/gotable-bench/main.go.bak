package main

import (
	"bufio"
	"flag"
	"fmt"
	"github.com/stevejiang/gotable/proto"
	"net"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"
)

var (
	host        = flag.String("h", "127.0.0.1:6688", "Server host address ip:port")
	cliNum      = flag.Int("c", 10, "Number of parallel connections")
	reqNum      = flag.Int("n", 100000, "Total number of requests")
	dataSize    = flag.Int("d", 4, "Data size of SET/GET value in bytes")
	testCase    = flag.String("t", "set,get", "Run the comma separated list of tests")
	histogram   = flag.Int("histogram", 0, "Print histogram of operation timings")
	verbose     = flag.Int("v", 0, "Verbose mode, if enabled it will slow down the test")
	maxProcs    = flag.Int("cpu", runtime.NumCPU(), "Go Max Procs")
	profileport = flag.String("profileport", "", "Profile port, such as 8080")
)

var valueData []byte

func main() {
	flag.Parse()
	if *maxProcs > 0 {
		runtime.GOMAXPROCS(*maxProcs)
	}

	var tests = strings.Split(*testCase, ",")
	for _, t := range tests {
		switch t {
		case "get":
			benchGet()
		case "set":
			benchPut()
		default:
			fmt.Printf("Unknown test case: %s\n", t)
		}
	}
}

type client struct {
	c       net.Conn
	r       *bufio.Reader
	headBuf []byte
	head    proto.PkgHead
	pkgBuf  []byte
	value   []byte
}

func newClient(link net.Conn) *client {
	var c = new(client)
	c.c = link
	c.r = bufio.NewReader(link)
	c.headBuf = make([]byte, proto.HeadSize)
	c.pkgBuf = make([]byte, 4096)

	c.value = make([]byte, *dataSize)
	for i := 0; i < *dataSize; i++ {
		c.value[i] = 'x'
	}

	return c
}

func benchmark(name string, op func(v int, client *client)) {
	var g sync.WaitGroup
	g.Add(*cliNum)

	var numChan = make(chan int, 10000)
	go func() {
		var n = *reqNum + 1000
		for i := 1000; i < n; i++ {
			numChan <- i
		}

		close(numChan)
	}()

	var recordHist = (*histogram != 0)
	var hists = make([]Histogram, *cliNum)

	start := time.Now()
	for i := 0; i < *cliNum; i++ {
		go func(id int) {
			defer g.Done()

			link, err := net.Dial("tcp", *host)
			if err != nil {
				fmt.Println("dial failed: ", err)
				return
			}

			var hist = &hists[id]
			hist.Clear()

			client := newClient(link)

			var opStart time.Time
			for {
				select {
				case v, ok := <-numChan:
					if !ok {
						return
					}

					if recordHist {
						opStart = time.Now()
					}

					op(v, client)

					if recordHist {
						d := time.Since(opStart)
						hist.Add(float64(d / 1000))
					}

					if v%10000 == 0 && v > 0 {
						elapsed := time.Since(start)
						speed := float64(v+1) * 1e9 / float64(elapsed)
						fmt.Printf("%-8s : %9.1f op/s    \r", name, speed)
					}
				}
			}
		}(i)
	}

	g.Wait()

	elapsed := time.Since(start)
	speed := float64(*reqNum) * 1e9 / float64(elapsed)
	fmt.Printf("%-8s : %9.1f op/s\n", name, speed)

	if recordHist {
		var hist = hists[0]
		for i := 1; i < len(hists); i++ {
			hist.Merge(&hists[i])
		}
		fmt.Printf("Microseconds per op:\n%s\n", hist.ToString())
	}
}

func benchPut() {
	var keyBuf = make([]byte, 0, 64)
	var op = func(v int, c *client) {
		key := strconv.AppendInt(keyBuf, int64(v), 10)
		var rowKey = key[0 : len(key)-3]
		var colKey = key[len(key)-3:]
		copy(c.value, key)

		c.put(rowKey, colKey, c.value)

		for i := 0; i < len(key) && i < len(c.value); i++ {
			c.value[i] = 'x'
		}
	}

	benchmark("SET", op)
}

func benchGet() {
	var keyBuf = make([]byte, 0, 64)
	var op = func(v int, c *client) {
		key := strconv.AppendInt(keyBuf, int64(v), 10)
		var rowKey = key[0 : len(key)-3]
		var colKey = key[len(key)-3:]

		c.get(rowKey, colKey)
	}

	benchmark("GET", op)
}

func (c *client) put(rowKey, colKey, value []byte) {
	var req proto.PkgCmdPutReq
	req.Cmd = proto.CmdPut
	req.RowKey = rowKey
	req.ColKey = colKey
	req.Value = value

	var pkg = c.pkgBuf
	n, err := req.Encode(&pkg)
	if err != nil {
		return
	}
	if len(pkg) != n {
		pkg = pkg[:n]
	}

	_, err = c.c.Write(pkg)
	if err != nil {
		fmt.Printf("Write failed: %s\n", err)
		return
	}

	pkg, err = proto.ReadPkg(c.r, c.headBuf, &c.head, c.pkgBuf)
	if err != nil {
		fmt.Printf("ReadPkg failed: %s\n", err)
		return
	}

	if *verbose != 0 {
		var resp proto.PkgCmdPutResp
		resp.Decode(pkg)
		fmt.Printf("rowKey: %2s, colKey: %s\n", string(resp.RowKey), string(resp.ColKey))
	}
}

func (c *client) get(rowKey, colKey []byte) {
	var req proto.PkgCmdGetReq
	req.Cmd = proto.CmdGet
	req.RowKey = rowKey
	req.ColKey = colKey

	var pkg = c.pkgBuf
	n, err := req.Encode(&pkg)
	if err != nil {
		return
	}
	if len(pkg) != n {
		pkg = pkg[:n]
	}

	_, err = c.c.Write(pkg)
	if err != nil {
		fmt.Printf("Write failed: %s\n", err)
		return
	}

	pkg, err = proto.ReadPkg(c.r, c.headBuf, &c.head, c.pkgBuf)
	if err != nil {
		fmt.Printf("ReadPkg failed: %s\n", err)
		return
	}

	if *verbose != 0 {
		var resp proto.PkgCmdGetResp
		resp.Decode(pkg)
		fmt.Printf("rowKey: %2s, colKey: %s, value: %s\n",
			string(resp.RowKey), string(resp.ColKey), string(resp.Value))
	}
}
